<h1> TechMartApi </h1>

<h2> Команды</h2>

<h3>Установка библиотек:</h3>  

```
pip install -r requirements.txt
```

<h3>Запуск сервера:</h3>

(Запуск с помощью ```python main.py``` не работает! Для запуска пожалуйста используйте ```uvicorn```)
```
uvicorn main:app --reload
```

Для просмотра документации и получения примеров заполнения напишите ```/docs``` в конце полученой ссылки
```
http://127.0.0.1:8000/docs
```

<h2>Настройте переменные окружения.</h2> 

Создайте файл .env в корневой папке проекта и заполните его:

```
# .env
SECRET_KEY="your_super_secret_key_that_is_long_and_random"
ALGORITHM="HS256"
ACCESS_TOKEN_EXPIRE_MINUTES=30
```

<h2> Контроль доступа на основе ролей</h2>
<p>Система строго разделяет права доступа в зависимости от роли пользователя, что обеспечивает безопасность и логику бизнес-процессов.</p> 

<h3>Администраторы</h3>

* Имеют полный доступ ко всей системе.
* Могут просматривать список всех пользователей (включая других администраторов).
* Могут создавать, удалять и редактировать товары.
* Могут удалять учетные записи любых пользователей (включая других администраторов).
* Могут просматривать любого пользователя без ограничения.
* ID администраторов для внутреннего учета начинается с префикса «a».

<h3>Работники</h3>

* Имеют права на управление товарами и покупателями.
* Могут просматривать список только работников и покупателей, но не видят администраторов.
* Могут создавать, удалять и редактировать товары.
* Могут удалять только учетные записи покупателей.
* Могут просматривать пользователей которые соотвествуют роли "работник" или польхователь.
* ID работников начинается с префикса «w».

<h3>Покупатели</h3>

* Имеют ограниченные права, предназначенные только для совершения покупок.
* Могут просматривать каталог товаров, выбирать и покупать их.
* Не могут просматривать списки пользователей или управлять товарами.
* ID покупателей начинается с префикса «c».

<h2> Эндпоинты API </h2>
<p>API предоставляет следующие маршруты для взаимодействия с системой:</p>

<h3>Регисстрация</h3>
  
Для создания пользователя перейдите в ```BODY``` > ```raw```
* POST ```/api/admin-reg``` — Регистрация администратора.
* POST ```/api/worker-reg``` — Регистрация работника.
* POST ```/api/customer-reg``` — Регистрация покупателя.

<h3>Аутентификация</h3>

* POST ```/api/token``` — Вход в систему и получение токена доступа.

Для входа в аккаунт перейдите в ```form-data``` и заполните ключи и занчения :
```
key     | value
username: myadmin 
password: strongpassword
```
После отправки запроса в ответ вы получите ```access_token```.

<h2>Доступ к защищенным эндпоинтам:</h2>

1. Скопируйте полученный ```access_token```.
2. Создайте новый запрос, например GET на ```http://127.0.0.1:8000/api/user/```.
3. Перейдите во вкладку ```Authorization```.
4. Выберите ```Type: Bearer Token```.
5. Вставьте скопированный токен в поле ```Token```.
6. Отправьте запрос. Вы получите список пользователей, так как у вас токен админа.

---
<h3>Управление пользователями (для администраторов и частично для работников)</h3>

* GET ```/api/user/``` — Выводит список пользователей.
* GET ```/api/user/{user_id}``` — Получить информацию о конкретном пользователе.
* DELETE ```api/delete-user/{user_id}``` — Удалить пользователя (доступно администраторам и работникам с ограничениями).

<h3>Управление категориями (только для администраторов и работников)</h3>

* GET ```/api/products/category/``` — Выводит список всех категорий.
* POST ```/api/products/category/``` — Создать новую категорию.
* GET ```/api/products/category/{category_name}``` — Выводит список товаров заданой категории.

<h3>Управление товарами</h3>

* GET ```/api/products/``` — Выводит список всех товаров (доступно всем авторизованным пользователям).
* POST ```/api/products/``` — Создать новый товар (только для администраторов и работников).
* DELETE ```/api/products/{product_id}``` — Удалить товар (только для администраторов и работников).
* POST ```/api/products/{product_id}/purchase``` — Купить товар (только для покупателей).

<h3>Редактирование товаров (только для администраторов и работников).</h3>

* PATCH ```/api/products/{product_id}``` — Отредактировать существующий товар.
* PATCH ```/api/products/{product_id}/form``` — Отредактировать существующий товар через form-body.

```
{
  "name": "string",
  "description": "string",
  "price": 0,
  "category": "string",
  "quantity": 0
}
```

<p>
  Отредактировать можно либо весь товар полностью либо укажите определенные поля которые должны быть изменены к примеру указать "name": "new_name"
</p>

* PUT ```/api/products/{product_id}/update-quantity``` — Отредактировать только количество товаров (только для администраторов и работников).

Чтобы добавить 30 единиц товара, а для того чтобы уменьшить количество товаров напишите отрицательное значение.
```
{
  "change": 30  /// или -30 шт
}
```

<h3>Поиск</h3>

* POST ```/api/products/search``` — Выводит список **ТОВАРОВ** и поиск мин-макс стоимости (доступно **ВСЕМ** авторизованным пользователям).
* POST ```/api/user/search``` — Выводит список **ПОЛЬЗОВАТЕЛЕЙ** (только для администраторов и работников).
* Универсальный поиск ```"search"``` ищет совпадения по нескольким ключевым полям (имя, ID, роль и т.д.)
* Специализированные фильтры (```"id"```, ```"username"```, ```"min_price"``` и т.д.) позволяют задать точные условия.
  
Пользователи
```
{
  "search": "string",///Универсальный поиск
  ///Фильтры
  "id": "string",
  "username": "string",
  "role": "string"
}
```

Товары
```
{
  "search": "string",///Универсальный поиск
  ///Фильтры
  "id": "string",
  "name": "string",
  "category": "string",
  "min_price": 0,
  "max_price": 0
}
```

<h2>Дополнительно</h2>

<h3>Валидация</h3>

Принцип работы валидации в API

Валидация в проекте является многоуровневой и распределена по нескольким файлам, каждый из которых выполняет свою специфическую задачу. Это обеспечивает как проверку данных, так и безопасность доступа.

```models/models.py``` Это первый и основной уровень валидации, отвечающий за структуру данных. С помощью Pydantic-моделей FastAPI автоматически проверяет, что все входящие запросы (например, тело POST-запроса) соответствуют заданной схеме: все обязательные поля присутствуют, и их типы данных корректны. Если данные невалидны, API автоматически возвращает ошибку 422 Unprocessable Entity.

```security/security.py``` Это ядро валидации пользователя и его прав доступа. Здесь находятся функции-зависимости (Depends), которые проверяют JWT-токен из заголовка запроса, его подлинность и срок действия (get_current_user). На основе этой базовой проверки строятся другие, более строгие, валидирующие роль пользователя (get_admin_user, get_worker_user).

```routers/auth.py``` Отвечает за валидацию при аутентификации. При попытке входа (/token) он проверяет совпадение логина и пароля. При регистрации — валидирует уникальность имени пользователя, чтобы избежать дубликатов.

```routers/products.py и routers/users.py``` На этом уровне происходит применение правил валидации для защиты конкретных эндпоинтов. Путем добавления зависимостей из security.py (например, Depends(get_worker_user)) в определение эндпоинта, доступ к нему ограничивается только для пользователей с подтвержденными правами. Здесь же может происходить и валидация бизнес-логики, например, проверка существования категории перед добавлением товара.

---

<h3>Безопасность и Инкапсуляция</h3>

Безопасность

Безопасность API обеспечивается на нескольких уровнях, чтобы защитить данные и контролировать доступ:

* Аутентификация на основе токенов: Доступ к защищенным эндпоинтам осуществляется с помощью JWT (JSON Web Tokens). Пользователь получает токен после успешного входа в систему, который он должен предоставлять при каждом последующем запросе.

* Хеширование паролей: Пароли пользователей никогда не хранятся в открытом виде. Они хешируются с использованием надежного алгоритма bcrypt через библиотеку passlib, что делает невозможным их восстановление.

* Защита от brute-force атак: Внедрен механизм ограничения частоты запросов (rate limiting) с помощью slowapi. Это не позволяет злоумышленникам многократно и быстро подбирать пароли или перегружать систему запросами.

* Сокрытие чувствительных данных: Секретные ключи и другие важные конфигурационные данные (например, SECRET_KEY для подписи токенов) хранятся в файле .env и не являются частью кода, что предотвращает их случайную утечку.

Инкапсуляция

Принцип инкапсуляции используется для разделения логики и сокрытия деталей реализации, что делает код более чистым, безопасным и простым в поддержке:

* Логика безопасности (security/security.py): Вся логика, связанная с созданием и проверкой токенов, а также с хешированием паролей, инкапсулирована в этом модуле. Другие части приложения просто вызывают его функции, не зная о деталях реализации.

* Работа с базой данных (database/db.py): Этот модуль полностью скрывает тот факт, что в качестве базы данных используются JSON-файлы. Он предоставляет простой интерфейс (например, get_all_users_db, save_all_products_db) для получения и сохранения данных, инкапсулируя всю логику чтения и записи файлов.

* Модели данных (models/models.py): Модели Pydantic инкапсулируют структуру и правила валидации для всех сущностей в системе (пользователей, товаров и т.д.). Это гарантирует, что данные всегда имеют ожидаемый формат.

---

<h3>Концепт работы API и Контроль доступа по ролям</h3>

Контроль доступа к данным построен на проверке токена и последующей проверке роли пользователя на стороне сервера. Это не так, что токен сам по себе разрешает или запрещает доступ; он лишь удостоверяет личность пользователя.

Концептуально процесс выглядит так:

1. Аутентификация и получение токена: Пользователь отправляет свои логин и пароль. Если они верны, сервер генерирует уникальный JWT, который содержит идентификатор пользователя (например, username) и срок действия.

2. Запрос к защищенному ресурсу: Пользователь делает запрос к эндпоинту (например, на получение списка всех пользователей), прикрепляя полученный токен в заголовке Authorization.

3. Валидация токена: Прежде чем выполнить основную логику, система через зависимости (Depends) вызывает функцию из модуля security.py. Эта функция:

    * Проверяет, что токен действителен (не подделан и не истек).

    * Извлекает из него идентификатор пользователя.

    * Находит этого пользователя в базе данных, чтобы получить его полную информацию, включая его роль (admin, worker или customer).

4. Проверка роли и прав доступа: Уже после успешной валидации токена система проверяет роль пользователя. Например, для доступа к эндпоинту delete_user требуется роль администратора. Если у пользователя с валидным токеном роль customer, доступ будет запрещен.

5. Фильтрация вывода: Даже если доступ разрешен, сам код эндпоинта может дополнительно фильтровать информацию. Например, при запросе списка пользователей (/user/) администратор увидит всех, а работник — только других работников и покупателей, но не администраторов. Это реализовано внутри самого эндпоинта.
